20/06/2018
-------------
Design adjustments needed:

1. make three_port_ram collision tolerant by changing read to write when there's r/w collision
2. add additional row and col processor output for when the multiplier and multiplicant is valid
   to make up for FIFO latency
3. add ve_ack to row processor to make up for memory latency

27/06/2018
-------------
Reverted adjustment 2 from above.

Gave up on the idea of a generic deriviative unit, as much sense as the idea makes. It's just too
tricky to have it work with both row and colomn processors. Instead I've made the modules
trow_processor and tcol_processor for transpose-row and column processing elements with derivative
calculation built in.

I also realised that having completely combinatorial positive halves of sigmoid and sigmoid-prime units
incurs way to much logic delay, so I modified sigmoidgen to add a massive pipeline register between
the product terms (AND-gates) and sum terms (OR-gates). I also realised that my signed sigmoid and
sigmoid-prime wrappers were pieces of shit. I've fixed all of these things and it still doesn't want
to run at 200Mhz so I'm settling on 150Mhz.

Next steps:

Ok, the Python prototype is coming into good use at long last (a year after it was first written,
procrastination is real). I'm going to need its help in testing trow_processor.

Specifically, I'm going to get real zl-1 vectors, take the first vector elements, and observe the
first dL-1 vector elements as well as the first columns of the weight adjustment matrixes. Then I
will convert everything to fixed point and feed the same data through a trow_processor.

When trow processor is solid I'll move onto tcol processor. When that is done, I will write the
script to metaprogram the top-level neuralnet IP module. When that is done, I will begin zynq block
design. When that is done, I will begin zynq software development...

27/06/2018
-------------
I remember now that a0 is the input vector and will not have a corresponding z0 vector. I'm leaning
towards duplicated sigmoid and sigmoid-prime fifos now.

10/07/2018
-------------
Generated test data for transpose row and column processing elements using the python scripts, verified
transpose row processor output. Finished coding transpose column processor, not yet tested.

02/09/2018
-------------
Life has been a trainwreck, new job has been stressful, and it's been hard to find time to work on Zynq.
Recently re-acquainted myself with the codebase and realised that the transpose column processing element
lacked the partial product output ports, which has been fixed. Also got rid of the old project folder in
favour of a form suitable for version control.

I'm afraid testing a single tcol PE won't be enough, need to put a few of them in series to test overall
behaviour.

Once tcol PE is tested I will start on the metaprogramming tool for the top module. Might use a preprocessing language
now that there's a stable place to put HDL design files.

18/09/2018
-------------
1. verified tcol output
2. wrote an FF-backed FIFO cache for the weight ram. this is neccessary because not all vector input to processing elements
   have to arrive from blockram-backed FIFOs (2-cycle latency); row processors are always ready to consume vector input,
   making the two-cycle delay unneeded.
  
   with the cache unit in place, we can get rid of the combinatiorial "ack" signal from the FIFO and use valid-out signals
   to drive consumer logic instead.

14/10/2018
------------
ideas:

1. put a status register behind AXI slave, use it to control behaviour, e.g. training on/off
   PS sideload can only happen when training is off, in which case take over the backprop ports
   to do PS sideload.

2. in row and col PE, track parameter input and "retirement", count how many parameters are in flight;
   use backpropagation and (in case of row processor) forward propagation FIFO remaining capacity to
   do flow control

3. use pipelined mux to make PS parameter sideload a "packet switched network"

4. use cached weight memory to make row processor vector input channel a slave interface

TODOs in this order:

1. get rid of dedicated "PS sideload" ports from weight memory, rename backprop ports to something else
   to indicate that the port will now be multiplexed

2. modify row, trow, col and tcol to use the new 0-latency ram and fifo

3. implement logic for idea 2

4. implement "layer" blocks consisting of arrays of row/tcol or trow/col processors

5. write some code for weaving "layer" blocks together to form neural net IP, simulate in TB

6. get AXI interface going, start PS software development

7. implement the PS sideload circuit

